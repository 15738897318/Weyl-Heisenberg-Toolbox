%% Weyl-Heisenberg Bases Toolbox
% Function "discretfix.m"
%% Описание:
% Функция дискретизации усеченного гауссиана для N количества отсчетов 
% по времени.
%% Примечание: 
% Форма гауссиана не зависит от значения среднеквадратического 
% отклонения.
%
%% Входные данные:
% sigma - среднеквадратическое отклонение,
% N - количество дискретных отсчетов по времени,
% eps - приближение к минимуму гауссиана (например, 1e-8).
%
%% Выходные данные:
% g - вектор дискретных отсчетов усеченного гауссиана.
function [ g ] = discretfix( sigma, N, eps )
%% 
% Идея аппроксимации функции усеченного гауссиана заключается в том, что
% исходя из свойств симметрии гауссиана достаточно обрабатывать лишь его
% положительную сторону и тем самым формировать весь гауссиан.
% 1. Происходит поиск минимума функции до определенного приближения Eps.
% минимум вычисляется за счет цикла, количество итераций которого
% определеяет точность вычисления минимума.
% 2. После чего вычисляются параметры дискретизации. В этом пункте
% происходит разделение алгоритмов для случая когда N четное число и 
% нечетное.
% 3. Далее происходит одновременное формирование сторон гауссиана.
% В частном случае центральный элемент вектора отсчетов функции есть
% максимальное значение, которое находится по свойствам гауссиана:
%                             Max = g(0)                            (1)
% Таким образом, происходит дискретизация функции усеченного гауссиана,
% соблюдая при этом его полную симметричность.
%% Начальное приблежение:
tmin = 0;

%% Нахождение позиции значения предела: min -> eps
for i = 0 : 0.1 : 1000
    yfunc = gaussian(i, sigma);
    if (yfunc < eps)
        tmin = i;
        break;
    end;
end;

%% Определение параметров дискретизации усеченного гауссиана:
dt = 2 * tmin / N; % интервал дискретизации
t = 0; % начальное значение
g = zeros(1, N); % Вектор значений функции

%% Алгоритм зеркального формирования гауссиана:
% Случай N - четное число.
if (mod(N, 2) == 0)
    N2 = floor(N / 2) - 1;
    m = N2 + 1;
    for n = N2 + 2 : 1 : N
        t = t + dt;
        g(n) = gaussian(t, sigma); % формирование в положительную сторону
        g(m) = g(n);  % формирование в отрицательную сторону
        m = m - 1;
    end;
% Случай N - нечетное число.
else
    N2 = floor(N / 2);
    m = N2;
    for n = N2 + 2 : 1 : N
        t = t + dt;
        g(n) = gaussian(t, sigma); % формирование в положительную сторону
        g(m) = g(n); % формирование в отрицательную сторону
        m = m - 1;
    end;
    % Обозначение максимума:
    g(N2 + 1) = gaussian(0, sigma);
end;
end